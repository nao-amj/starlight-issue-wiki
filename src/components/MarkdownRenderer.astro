---
import { getHighlighter } from 'shiki';
import { marked } from 'marked';
import { gfmHeadingId } from 'marked-gfm-heading-id';

interface Props {
  content: string;
  theme?: 'light' | 'dark' | 'auto';
}

const { content, theme = 'auto' } = Astro.props;

// Add GFM heading ID support to marked
marked.use(gfmHeadingId());

// Set up a highlighter instance that can be shared
const highlighter = await getHighlighter({
  themes: ['github-light', 'github-dark'],
  langs: ['javascript', 'typescript', 'html', 'css', 'json', 'markdown', 'python', 'java', 
          'c', 'cpp', 'csharp', 'go', 'rust', 'bash', 'shell', 'yaml', 'toml', 'sql'],
});

// Enhance marked renderer to better handle GitHub Markdown features
const renderer = new marked.Renderer();

// Improve table rendering
renderer.table = (header, body) => {
  return `<div class="table-container">
    <table>
      <thead>${header}</thead>
      <tbody>${body}</tbody>
    </table>
  </div>`;
};

// Improve code block rendering with syntax highlighting
renderer.code = (code, language) => {
  if (!language) {
    return `<pre><code>${code}</code></pre>`;
  }

  // Handle mermaid diagrams
  if (language === 'mermaid') {
    // 前処理: 'graph XX' 形式を 'flowchart XX' 形式に変換する
    let processedCode = code;
    if (code.trim().startsWith('graph ')) {
      // 'graph TB', 'graph LR', 'graph TD', 'graph RL' などを変換
      processedCode = code.replace(/^(\s*)graph\s+(TB|TD|BT|LR|RL)/, '$1flowchart $2');
    }
    
    return `<div class="mermaid-diagram">
      <pre class="mermaid">${processedCode}</pre>
    </div>`;
  }

  try {
    // Determine which theme to use
    const lightTheme = highlighter.getTheme('github-light');
    const darkTheme = highlighter.getTheme('github-dark');

    // Highlight the code for both themes - using synchronous API
    const lightHtml = highlighter.codeToHtml(code, { lang: language, theme: lightTheme });
    const darkHtml = highlighter.codeToHtml(code, { lang: language, theme: darkTheme });

    // Return code with theme toggle support
    return `<div class="code-block-container">
      <div class="code-header">
        <span class="code-language">${language}</span>
        <div class="code-actions">
          <button class="copy-button" data-code="${encodeURIComponent(code)}">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
          </button>
        </div>
      </div>
      <div class="code-block light-theme">${lightHtml}</div>
      <div class="code-block dark-theme">${darkHtml}</div>
    </div>`;
  } catch (error) {
    console.error('Error highlighting code:', error);
    return `<pre><code class="language-${language}">${code}</code></pre>`;
  }
};

// Use the custom renderer
marked.use({ renderer });

// Process the markdown content
const processedContent = await marked.parse(content, { async: true });
---

<div class="markdown-content">
  <div set:html={processedContent} />
</div>

<style>
  .markdown-content :global(h1),
  .markdown-content :global(h2),
  .markdown-content :global(h3),
  .markdown-content :global(h4),
  .markdown-content :global(h5),
  .markdown-content :global(h6) {
    margin-top: 1.5em;
    margin-bottom: 0.5em;
    line-height: 1.3;
  }

  .markdown-content :global(h1) {
    font-size: 2rem;
  }

  .markdown-content :global(h2) {
    font-size: 1.5rem;
    border-bottom: 1px solid var(--sl-color-border);
    padding-bottom: 0.3em;
  }

  .markdown-content :global(h3) {
    font-size: 1.3rem;
  }

  .markdown-content :global(p) {
    margin: 1em 0;
    line-height: 1.7;
  }

  .markdown-content :global(blockquote) {
    border-left: 4px solid var(--sl-color-border);
    margin: 1em 0;
    padding: 0 1em;
    color: var(--sl-color-text-accent);
  }

  .markdown-content :global(ul),
  .markdown-content :global(ol) {
    margin: 1em 0;
    padding-left: 2em;
  }

  .markdown-content :global(li) {
    margin: 0.5em 0;
  }

  .markdown-content :global(img) {
    max-width: 100%;
    height: auto;
    border-radius: 0.25rem;
  }

  /* Table styles */
  .markdown-content :global(.table-container) {
    overflow-x: auto;
    margin: 1.5em 0;
  }

  .markdown-content :global(table) {
    width: 100%;
    border-collapse: collapse;
    border-spacing: 0;
  }

  .markdown-content :global(table th) {
    background-color: var(--sl-color-gray-6);
    text-align: left;
    font-weight: 600;
    padding: 0.75em;
    border: 1px solid var(--sl-color-border);
  }

  .markdown-content :global(table td) {
    padding: 0.75em;
    border: 1px solid var(--sl-color-border);
  }

  .markdown-content :global(table tr:nth-child(2n)) {
    background-color: var(--sl-color-gray-7);
  }

  /* Code block styles */
  .markdown-content :global(.code-block-container) {
    margin: 1.5em 0;
    border-radius: 0.5rem;
    overflow: hidden;
    border: 1px solid var(--sl-color-border);
  }

  .markdown-content :global(.code-header) {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5em 1em;
    background-color: var(--sl-color-gray-6);
    border-bottom: 1px solid var(--sl-color-border);
  }

  .markdown-content :global(.code-language) {
    font-size: 0.8em;
    font-weight: 600;
    color: var(--sl-color-text-accent);
    text-transform: uppercase;
  }

  .markdown-content :global(.code-actions) {
    display: flex;
    gap: 0.5em;
  }

  .markdown-content :global(.copy-button) {
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 0.2em;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--sl-color-text-accent);
    opacity: 0.7;
    transition: opacity 0.2s;
  }

  .markdown-content :global(.copy-button:hover) {
    opacity: 1;
  }

  .markdown-content :global(.code-block) {
    margin: 0;
    overflow-x: auto;
  }

  .markdown-content :global(.code-block pre) {
    margin: 0;
    padding: 1em;
  }

  /* Theme-specific code rendering */
  .markdown-content :global(.light-theme) {
    display: var(--light-theme-display, block);
  }

  .markdown-content :global(.dark-theme) {
    display: var(--dark-theme-display, none);
  }

  :global(.dark) .markdown-content :global(.light-theme) {
    display: var(--dark-light-theme-display, none);
  }

  :global(.dark) .markdown-content :global(.dark-theme) {
    display: var(--dark-dark-theme-display, block);
  }

  /* Mermaid diagram styles */
  .markdown-content :global(.mermaid-diagram) {
    margin: 1.5em 0;
    text-align: center;
    background-color: white;
    padding: 1em;
    border-radius: 0.5rem;
    border: 1px solid var(--sl-color-border);
    overflow: auto;
    max-width: 100%;
    width: 100%;
  }

  /* Force mermaid SVG to fit container */
  .markdown-content :global(.mermaid-diagram svg) {
    max-width: 100% !important;
    height: auto !important;
  }
  
  :global(.dark) .markdown-content :global(.mermaid-diagram) {
    background-color: #1a1a1a;
  }

  /* Mobile optimizations */
  @media (max-width: 640px) {
    .markdown-content :global(pre) {
      font-size: 0.85em;
    }
    
    .markdown-content :global(table) {
      font-size: 0.85em;
    }
    
    .markdown-content :global(.code-header) {
      padding: 0.3em 0.6em;
    }
  }
</style>

<script>
  declare global {
    interface Window {
      mermaid: any;
    }
  }

  // Copy button functionality
  document.addEventListener('DOMContentLoaded', () => {
    const copyButtons = document.querySelectorAll('.copy-button');
    
    copyButtons.forEach(button => {
      button.addEventListener('click', async () => {
        const code = decodeURIComponent((button as HTMLElement).dataset.code || '');
        
        try {
          await navigator.clipboard.writeText(code);
          
          // Show feedback
          const originalHTML = button.innerHTML;
          button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
          button.style.color = 'var(--sl-color-green-high)';
          
          // Reset after 2 seconds
          setTimeout(() => {
            button.innerHTML = originalHTML;
            button.style.color = '';
          }, 2000);
        } catch (err) {
          console.error('Failed to copy code:', err);
        }
      });
    });
  });

  // Initialize Mermaid for graph rendering
  document.addEventListener('DOMContentLoaded', async () => {
    // Mermaidを動的に読み込む
    try {
      // スクリプトを読み込み
      await new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
      
      // mermaidグローバルオブジェクトが存在することを確認
      if (window.mermaid) {
        console.log('Mermaid loading succeeded.');
        
        // 詳細なログを有効化
        window.mermaid.mermaidAPI.initialize({ 
          startOnLoad: false,
          logLevel: 'debug'
        });
        
        // 初期化
        window.mermaid.initialize({
          startOnLoad: false, // 自動処理を無効化
          theme: document.documentElement.classList.contains('dark') ? 'dark' : 'default',
          securityLevel: 'loose',
          logLevel: 'warn',
          flowchart: {
            useMaxWidth: true,
            htmlLabels: true,
            curve: 'basis',
            diagramPadding: 8
          },
          gantt: { 
            titleTopMargin: 25,
            barHeight: 20,
            barGap: 4,
            topPadding: 50,
            sidePadding: 50
          },
          pie: {
            useWidth: true,
            textPosition: 0.5
          }
        });
        
        try {
          // プリレンダリングステップとして全てのダイアグラムを解析するが、まだレンダリングはしない
          const diagrams = document.querySelectorAll('.mermaid');
          diagrams.forEach((diagram, index) => {
            try {
              const graphCode = diagram.textContent || '';
              if (graphCode) {
                console.log(`Parsing diagram ${index + 1}:`, graphCode.substring(0, 30) + '...');
                window.mermaid.parse(graphCode);
              }
            } catch (parseError) {
              console.error(`Parse error in diagram ${index + 1}:`, parseError);
            }
          });
          
          // 明示的にすべてのダイアグラムをレンダリング
          await window.mermaid.run({
            querySelector: '.mermaid',
            suppressErrors: false
          });
          
          console.log('Mermaid diagrams rendered successfully.');
        } catch (renderError) {
          console.error('Error during Mermaid rendering:', renderError);
          
          // エラーリカバリー: ダイアグラムを1つずつレンダリングを試みる
          console.log('Attempting to render diagrams individually...');
          const diagrams = document.querySelectorAll('.mermaid');
          diagrams.forEach(async (diagram, index) => {
            try {
              // graph形式を検出して変換
              const originalContent = diagram.textContent || '';
              if (originalContent.trim().startsWith('graph ')) {
                // IDを付与して個別に処理
                const id = `mermaid-diagram-${index}`;
                diagram.id = id;
                
                // graph構文をflowchart構文に変換して再レンダリング
                const convertedContent = originalContent.replace(/^(\s*)graph\s+(TB|TD|BT|LR|RL)/, '$1flowchart $2');
                diagram.textContent = convertedContent;
                
                console.log(`Converting diagram ${index + 1} from graph to flowchart:`, {
                  original: originalContent.substring(0, 30) + '...',
                  converted: convertedContent.substring(0, 30) + '...'
                });
                
                // 個別にレンダリング
                await window.mermaid.mermaidAPI.render(id, convertedContent, (svgCode) => {
                  diagram.innerHTML = svgCode;
                });
              }
            } catch (individualError) {
              console.error(`Error rendering diagram ${index + 1}:`, individualError);
            }
          });
        }
      } else {
        console.error('Mermaid was not loaded properly');
      }
    } catch (error) {
      console.error('Failed to initialize Mermaid:', error);
    }

    // テーマ変更時にMermaidを更新
    const observer = new MutationObserver(async (mutations) => {
      for (const mutation of mutations) {
        if (mutation.attributeName === 'class' && 
            window.mermaid && 
            typeof window.mermaid.initialize === 'function') {
          const isDark = document.documentElement.classList.contains('dark');
          
          // 再初期化
          window.mermaid.initialize({
            startOnLoad: false,
            theme: isDark ? 'dark' : 'default',
            securityLevel: 'loose',
            flowchart: {
              useMaxWidth: true,
              htmlLabels: true,
              curve: 'basis',
              diagramPadding: 8
            },
            gantt: { 
              titleTopMargin: 25,
              barHeight: 20,
              barGap: 4,
              topPadding: 50,
              sidePadding: 50
            },
            pie: {
              useWidth: true,
              textPosition: 0.5
            }
          });
          
          // すべてのダイアグラムを再レンダリング
          try {
            console.log('Theme changed, re-rendering Mermaid diagrams...');
            await window.mermaid.run({
              querySelector: '.mermaid'
            });
          } catch (error) {
            console.error('Error re-rendering Mermaid diagrams after theme change:', error);
          }
        }
      }
    });

    observer.observe(document.documentElement, { attributes: true });
  });
</script>
