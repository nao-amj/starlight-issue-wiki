---
import type { GitHubIssue } from '../data/types';
import { findBidirectionalLinks } from '../lib/zettelkasten';
import { BASE_PATH } from '../config';

export interface Props {
  issues: GitHubIssue[];
  currentIssueNumber?: number;
  showFullGraph?: boolean;
}

const { issues, currentIssueNumber, showFullGraph = false } = Astro.props;

// 双方向リンクを検出
const bidirectionalLinks = findBidirectionalLinks(issues);

// グラフデータの準備
const graphData = {
  nodes: issues.map(issue => ({
    id: issue.number,
    title: issue.title,
    url: `${BASE_PATH}/wiki/${issue.number}`,
    isCurrent: issue.number === currentIssueNumber,
    labels: issue.labels ? issue.labels.map(label => 
      typeof label === 'object' ? label.name : label
    ) : [],
    state: issue.state || 'open',
    comments: issue.comments || 0,
    updated_at: issue.updated_at,
    created_at: issue.created_at
  })),
  links: []
};

// リンクデータの準備
issues.forEach(issue => {
  if (!issue.body) return;
  
  // [[...]]形式のリンクを検出
  const wikiLinks = issue.body.match(/\[\[(.*?)\]\]/g);
  if (wikiLinks) {
    wikiLinks.forEach(link => {
      const linkedTitle = link.substring(2, link.length - 2).trim();
      const linkedIssue = issues.find(i => 
        i.title.toLowerCase() === linkedTitle.toLowerCase() ||
        i.title.toLowerCase().includes(linkedTitle.toLowerCase())
      );
      
      if (linkedIssue && linkedIssue.number !== issue.number) {
        graphData.links.push({
          source: issue.number,
          target: linkedIssue.number,
          bidirectional: bidirectionalLinks.has(issue.number) && 
            bidirectionalLinks.get(issue.number)?.includes(linkedIssue.number),
          type: 'wiki'
        });
      }
    });
  }
  
  // #番号形式のリンクを検出
  const issueRefs = issue.body.match(/#(\d+)/g);
  if (issueRefs) {
    issueRefs.forEach(ref => {
      const refNumber = parseInt(ref.substring(1), 10);
      const refIssue = issues.find(i => i.number === refNumber);
      
      if (refIssue && refIssue.number !== issue.number) {
        // 重複リンクを防ぐ
        const existingLink = graphData.links.find(
          link => (link.source === issue.number && link.target === refIssue.number) ||
                 (link.source === refIssue.number && link.target === issue.number)
        );
        
        if (!existingLink) {
          graphData.links.push({
            source: issue.number,
            target: refIssue.number,
            bidirectional: bidirectionalLinks.has(issue.number) && 
              bidirectionalLinks.get(issue.number)?.includes(refIssue.number),
            type: 'reference'
          });
        }
      }
    });
  }
});

// 小さいグラフの場合はフィルタリング
let filteredGraphData = graphData;
if (!showFullGraph && currentIssueNumber) {
  // 現在のノードと直接リンクしているノードのみを表示
  const connectedNodeIds = new Set();
  connectedNodeIds.add(currentIssueNumber);
  
  graphData.links.forEach(link => {
    if (link.source === currentIssueNumber) {
      connectedNodeIds.add(link.target);
    }
    if (link.target === currentIssueNumber) {
      connectedNodeIds.add(link.source);
    }
  });
  
  filteredGraphData = {
    nodes: graphData.nodes.filter(node => connectedNodeIds.has(node.id)),
    links: graphData.links.filter(link => 
      connectedNodeIds.has(link.source) && connectedNodeIds.has(link.target)
    )
  };
}

// D3.jsにわたすデータをJSON文字列として埋め込む
const dataJson = JSON.stringify(showFullGraph ? graphData : filteredGraphData);
---

<div class="knowledge-graph-container">
  <div id="knowledge-graph" class={showFullGraph ? 'full-graph' : 'mini-graph'} data-current-id={currentIssueNumber || 0}>
    <!-- グラフはJavaScriptで描画 -->
    <div class="graph-loading">
      <span class="loading-spinner"></span>
      <span>グラフを読み込み中...</span>
    </div>
  </div>
  
  {showFullGraph && (
    <div class="graph-controls">
      <div class="graph-search">
        <input type="text" id="node-search" placeholder="ノードを検索..." />
      </div>
      <div class="graph-buttons">
        <button id="zoom-in" class="graph-button" title="拡大">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="8"></circle>
            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
            <line x1="11" y1="8" x2="11" y2="14"></line>
            <line x1="8" y1="11" x2="14" y2="11"></line>
          </svg>
        </button>
        <button id="zoom-out" class="graph-button" title="縮小">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="8"></circle>
            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
            <line x1="8" y1="11" x2="14" y2="11"></line>
          </svg>
        </button>
        <button id="reset-graph" class="graph-button" title="リセット">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
            <path d="M3 3v5h5"></path>
          </svg>
        </button>
        <button id="toggle-legend" class="graph-button" title="凡例表示">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
          </svg>
        </button>
        <button id="toggle-labels" class="graph-button" title="ラベル表示">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="3" y1="9" x2="21" y2="9"></line>
            <line x1="3" y1="15" x2="21" y2="15"></line>
            <line x1="9" y1="3" x2="9" y2="21"></line>
            <line x1="15" y1="3" x2="15" y2="21"></line>
          </svg>
        </button>
        <button id="toggle-physics" class="graph-button" title="物理シミュレーション">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="2" y1="12" x2="22" y2="12"></line>
            <line x1="12" y1="2" x2="12" y2="22"></line>
          </svg>
        </button>
      </div>
    </div>
  )}
  
  {showFullGraph && (
    <div class="graph-panel">
      <div id="graph-info" class="graph-info-panel">
        <h3>グラフ情報</h3>
        <div class="graph-stats">
          <div class="graph-stat">
            <span class="stat-label">ノード数:</span>
            <span class="stat-value">{graphData.nodes.length}</span>
          </div>
          <div class="graph-stat">
            <span class="stat-label">リンク数:</span>
            <span class="stat-value">{graphData.links.length}</span>
          </div>
          <div class="graph-stat">
            <span class="stat-label">双方向リンク:</span>
            <span class="stat-value">{graphData.links.filter(link => link.bidirectional).length}</span>
          </div>
        </div>
        <div id="node-details" class="node-details">
          <div class="no-selection">ノードを選択すると詳細が表示されます</div>
        </div>
      </div>
    </div>
  )}
</div>

<style>
  .knowledge-graph-container {
    width: 100%;
    overflow: hidden;
    border-radius: 8px;
    border: 1px solid #eee;
    margin: 1rem 0;
    position: relative;
  }
  
  .dark .knowledge-graph-container {
    border-color: #444;
  }
  
  #knowledge-graph {
    width: 100%;
    background-color: #f9f9f9;
    position: relative;
    overflow: hidden;
  }
  
  .dark #knowledge-graph {
    background-color: #1a1a1a;
  }
  
  .mini-graph {
    height: 250px;
  }
  
  .full-graph {
    height: 600px;
  }
  
  .graph-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    color: #666;
    font-size: 0.9rem;
  }
  
  .dark .graph-loading {
    color: #ccc;
  }
  
  .loading-spinner {
    display: inline-block;
    width: 30px;
    height: 30px;
    border: 3px solid rgba(0, 0, 0, 0.1);
    border-radius: 50%;
    border-top-color: var(--color-primary);
    animation: spin 1s ease-in-out infinite;
    margin-bottom: 0.5rem;
  }
  
  .dark .loading-spinner {
    border-color: rgba(255, 255, 255, 0.1);
    border-top-color: var(--color-primary);
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  .graph-controls {
    position: absolute;
    bottom: 10px;
    right: 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 10;
  }

  .graph-search {
    margin-bottom: 5px;
  }

  .graph-search input {
    padding: 5px 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    width: 100%;
    font-size: 14px;
  }

  .dark .graph-search input {
    background-color: #333;
    border-color: #555;
    color: #eee;
  }

  .graph-buttons {
    display: flex;
    gap: 5px;
  }
  
  .graph-button {
    background-color: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 5px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    color: #555;
  }
  
  .dark .graph-button {
    background-color: #333;
    border-color: #555;
    color: #ccc;
  }
  
  .graph-button:hover {
    background-color: #f0f0f0;
    transform: translateY(-2px);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  }
  
  .dark .graph-button:hover {
    background-color: #444;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
  }

  .graph-button.active {
    background-color: var(--color-primary, #4f6df5);
    color: white;
  }

  .graph-panel {
    position: absolute;
    top: 10px;
    left: 10px;
    max-width: 300px;
    max-height: 580px;
    overflow-y: auto;
    z-index: 10;
  }

  .graph-info-panel {
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    margin-bottom: 10px;
  }

  .dark .graph-info-panel {
    background-color: rgba(40, 40, 40, 0.9);
    color: #eee;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
  }

  .graph-info-panel h3 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 16px;
    border-bottom: 1px solid #eee;
    padding-bottom: 8px;
  }

  .dark .graph-info-panel h3 {
    border-bottom-color: #444;
  }

  .graph-stats {
    margin-bottom: 15px;
  }

  .graph-stat {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
    font-size: 14px;
  }

  .stat-label {
    font-weight: 500;
  }

  .stat-value {
    color: var(--color-primary, #4f6df5);
    font-weight: 600;
  }

  .dark .stat-value {
    color: #7b96ff;
  }

  .node-details {
    font-size: 14px;
  }

  .node-details h4 {
    margin: 0 0 10px 0;
    font-size: 15px;
    color: var(--color-primary, #4f6df5);
  }

  .dark .node-details h4 {
    color: #7b96ff;
  }

  .node-details .node-meta {
    margin-bottom: 10px;
  }

  .node-details .node-meta div {
    display: flex;
    justify-content: space-between;
    margin-bottom: 3px;
  }

  .node-details .node-links {
    border-top: 1px solid #eee;
    padding-top: 10px;
  }

  .dark .node-details .node-links {
    border-top-color: #444;
  }

  .node-details .node-links h5 {
    margin: 0 0 5px 0;
    font-size: 14px;
  }

  .node-details .no-selection {
    color: #999;
    font-style: italic;
    text-align: center;
    padding: 20px 0;
  }

  .node-details .link-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 150px;
    overflow-y: auto;
  }

  .node-details .link-list li {
    margin-bottom: 5px;
    font-size: 13px;
  }

  .node-details .link-list a {
    color: var(--color-primary, #4f6df5);
    text-decoration: none;
    display: block;
    padding: 3px 0;
  }

  .dark .node-details .link-list a {
    color: #7b96ff;
  }

  .node-details .link-list a:hover {
    text-decoration: underline;
  }
  
  /* D3.js グラフのスタイル */
  :global(.graph-node) {
    cursor: pointer;
    transition: fill 0.3s, r 0.3s;
  }
  
  :global(.graph-node:hover) {
    stroke: #f04050;
    stroke-width: 2px;
  }
  
  :global(.graph-node.current) {
    stroke-width: 2px;
    stroke: #f04050;
  }

  :global(.graph-node.selected) {
    stroke-width: 3px;
    stroke: #f04050;
  }
  
  :global(.graph-link) {
    stroke-opacity: 0.6;
    transition: stroke 0.3s, stroke-width 0.3s, stroke-opacity 0.3s;
  }
  
  :global(.graph-link:hover) {
    stroke-opacity: 1;
    stroke-width: 2px;
  }
  
  :global(.graph-link.bidirectional) {
    stroke-width: 2px;
  }

  :global(.graph-link.highlighted) {
    stroke-opacity: 1;
    stroke-width: 3px;
    stroke: #f04050;
  }
  
  :global(.node-label) {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    font-size: 10px;
    pointer-events: none;
    text-anchor: middle;
    transition: opacity 0.3s;
    user-select: none;
  }
  
  .dark :global(.node-label) {
    fill: #eee;
  }

  :global(.node-label.highlighted) {
    font-weight: bold;
    font-size: 12px;
    fill: #f04050;
  }
  
  :global(.node-tooltip) {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.9);
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    z-index: 100;
    max-width: 250px;
    transition: opacity 0.2s;
    opacity: 0;
  }
  
  .dark :global(.node-tooltip) {
    background-color: rgba(40, 40, 40, 0.9);
    color: #eee;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
  }
  
  :global(.node-tooltip-title) {
    font-weight: bold;
    margin-bottom: 4px;
    color: var(--color-primary);
  }
  
  :global(.node-tooltip-info) {
    font-size: 11px;
    color: #666;
  }
  
  .dark :global(.node-tooltip-info) {
    color: #ccc;
  }
  
  /* 内部凡例のスタイル */
  :global(.graph-legend) {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 4px;
    padding: 10px;
    box-shadow: 0 1px 5px rgba(0, 0, 0, 0.15);
    font-size: 12px;
    max-width: 180px;
    z-index: 10;
    transition: all 0.3s;
    transform-origin: top left;
  }
  
  .dark :global(.graph-legend) {
    background-color: rgba(40, 40, 40, 0.9);
    color: #eee;
    box-shadow: 0 1px 5px rgba(0, 0, 0, 0.3);
  }
  
  :global(.legend-title) {
    font-weight: bold;
    margin-bottom: 5px;
    font-size: 13px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  :global(.legend-item) {
    display: flex;
    align-items: center;
    margin-bottom: 4px;
  }
  
  :global(.legend-color) {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 8px;
    display: inline-block;
  }
  
  :global(.legend-line) {
    width: 20px;
    height: 2px;
    margin-right: 8px;
  }
  
  :global(.legend-close) {
    cursor: pointer;
    font-size: 14px;
    opacity: 0.7;
  }
  
  :global(.legend-close:hover) {
    opacity: 1;
  }

  /* レスポンシブ対応 */
  @media (max-width: 768px) {
    .graph-controls {
      bottom: 10px;
      right: 10px;
      flex-direction: column;
    }

    .graph-panel {
      position: static;
      max-width: 100%;
      margin-top: 10px;
    }

    .graph-info-panel {
      margin-bottom: 0;
    }

    .full-graph {
      height: 400px;
    }
  }
</style>

<script>
  // D3.jsを使用したグラフの描画
  document.addEventListener('DOMContentLoaded', () => {
    // 必要なライブラリを動的にロード
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/d3@7';
    script.onload = initGraph;
    document.head.appendChild(script);
    
    function initGraph() {
      const graphElement = document.getElementById('knowledge-graph');
      if (!graphElement) return;
      
      // コンテナデータ
      const graphData = JSON.parse(graphElement.getAttribute('data-graph') || '{"nodes":[],"links":[]}');
      const isFullGraph = graphElement.classList.contains('full-graph');
      const currentId = parseInt(graphElement.getAttribute('data-current-id') || '0', 10);
      
      // グラフの読み込み中表示を削除
      graphElement.querySelector('.graph-loading')?.remove();
      
      // SVG要素の作成
      const width = graphElement.clientWidth;
      const height = graphElement.clientHeight;
      
      const svg = d3.select('#knowledge-graph')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, width, height]);
      
      // ズーム機能の定義
      const zoom = d3.zoom()
        .scaleExtent([0.1, 5])
        .on('zoom', (event) => {
          container.attr('transform', event.transform);
          // ズームレベルに応じてラベルの表示を調整
          adjustLabels(event.transform.k);
        });
      
      // SVGにズーム機能を追加
      svg.call(zoom);
      
      // グループコンテナ（ズーム用）
      const container = svg.append('g')
        .attr('class', 'graph-container');
      
      // リンクを描画するためのグループ
      const link = container.append('g')
        .attr('class', 'links')
        .selectAll('line')
        .data(graphData.links)
        .enter().append('line')
        .attr('class', d => `graph-link ${d.bidirectional ? 'bidirectional' : ''} ${d.type || ''}`)
        .attr('stroke', d => d.bidirectional ? '#0fa968' : '#999')
        .attr('stroke-width', d => d.bidirectional ? 2 : 1);
      
      // ノードを描画するためのグループ
      const node = container.append('g')
        .attr('class', 'nodes')
        .selectAll('circle')
        .data(graphData.nodes)
        .enter().append('circle')
        .attr('class', d => `graph-node ${d.isCurrent ? 'current' : ''}`)
        .attr('r', d => d.isCurrent ? 8 : getNodeSize(d))
        .attr('fill', d => d.isCurrent ? '#f04050' : getNodeColor(d))
        .on('mouseover', nodeMouseOver)
        .on('mouseout', nodeMouseOut)
        .on('click', nodeClicked);
      
      // ラベルの描画（デフォルトでは表示）
      const label = container.append('g')
        .attr('class', 'labels')
        .selectAll('text')
        .data(graphData.nodes)
        .enter().append('text')
        .attr('class', d => `node-label ${d.isCurrent ? 'current' : ''}`)
        .attr('dy', d => d.isCurrent ? '-1.2em' : '-0.5em')
        .text(d => truncateLabel(d.title))
        .style('opacity', 1); // デフォルトで全てのラベルを表示
      
      // ツールチップの作成
      const tooltip = d3.select('body').append('div')
        .attr('class', 'node-tooltip')
        .style('opacity', 0);
      
      // 凡例の追加（グラフ内に直接表示）
      if (isFullGraph) {
        const legend = d3.select('#knowledge-graph')
          .append('div')
          .attr('class', 'graph-legend')
          .style('display', 'block'); // デフォルトでは表示
        
        legend.append('div')
          .attr('class', 'legend-title')
          .html('凡例 <span class="legend-close">×</span>');
        
        // ノードタイプの凡例
        const nodeTypes = [
          { name: '通常ページ', color: '#4f6df5' },
          { name: '現在のページ', color: '#f04050' },
          { name: 'ドキュメント', color: '#0075ca' },
          { name: 'Wiki', color: '#7057ff' },
          { name: '機能', color: '#a2eeef' }
        ];
        
        nodeTypes.forEach(type => {
          legend.append('div')
            .attr('class', 'legend-item')
            .html(`<span class="legend-color" style="background-color: ${type.color};"></span>${type.name}`);
        });
        
        // 線タイプの凡例
        legend.append('div')
          .attr('class', 'legend-item')
          .html('<span class="legend-line" style="background-color: #999;"></span>片方向リンク');
        
        legend.append('div')
          .attr('class', 'legend-item')
          .html('<span class="legend-line" style="background-color: #0fa968;"></span>双方向リンク');
        
        // 凡例ボタンのイベント
        d3.select('#toggle-legend').on('click', () => {
          const legendElem = d3.select('.graph-legend');
          const isVisible = legendElem.style('display') !== 'none';
          legendElem.style('display', isVisible ? 'none' : 'block');
          d3.select('#toggle-legend').classed('active', !isVisible);
        });
        
        // 凡例の閉じるボタン
        d3.select('.legend-close').on('click', () => {
          d3.select('.graph-legend').style('display', 'none');
          d3.select('#toggle-legend').classed('active', false);
        });

        // ラベル表示切り替え（デフォルトでオン）
        const toggleLabelsBtn = d3.select('#toggle-labels');
        toggleLabelsBtn.classed('active', true);
        
        toggleLabelsBtn.on('click', function() {
          const button = d3.select(this);
          const showLabels = button.classed('active');
          
          button.classed('active', !showLabels);
          
          if (showLabels) {
            // ラベルを非表示
            label.style('opacity', d => d.isCurrent ? 1 : 0);
          } else {
            // ラベルを表示
            label.style('opacity', 1);
          }
        });

        // 物理シミュレーション切り替え
        let simulationRunning = true;
        d3.select('#toggle-physics').classed('active', true).on('click', function() {
          const button = d3.select(this);
          simulationRunning = !simulationRunning;
          
          button.classed('active', simulationRunning);
          
          if (simulationRunning) {
            simulation.alpha(0.3).restart();
          } else {
            simulation.stop();
          }
        });

        // ノード検索
        d3.select('#node-search').on('input', function() {
          const searchTerm = this.value.toLowerCase();
          
          if (!searchTerm) {
            // 検索がクリアされたら元の表示に戻す
            node.style('opacity', 1);
            link.style('opacity', 0.6);
            label.style('opacity', d => 
              d3.select('#toggle-labels').classed('active') ? 1 : (d.isCurrent ? 1 : 0)
            );
            return;
          }
          
          // マッチするノードを検索
          const matchingNodes = graphData.nodes.filter(d => 
            d.title.toLowerCase().includes(searchTerm)
          );
          
          const matchingIds = new Set(matchingNodes.map(d => d.id));
          
          // マッチするノードを強調
          node.style('opacity', d => matchingIds.has(d.id) ? 1 : 0.2);
          
          // マッチするノードに関連するリンクを強調
          link.style('opacity', d => 
            matchingIds.has(d.source.id) && matchingIds.has(d.target.id) ? 0.8 : 0.1
          );
          
          // マッチするノードのラベルを表示
          label
            .style('opacity', d => matchingIds.has(d.id) ? 1 : 0.1)
            .classed('highlighted', d => matchingIds.has(d.id));
        });
      }
      
      // ノードの色を決定する関数
      function getNodeColor(node) {
        if (node.isCurrent) return '#f04050';
        if (node.labels && node.labels.length > 0) {
          if (node.labels.includes('documentation')) return '#0075ca';
          if (node.labels.includes('feature')) return '#a2eeef';
          if (node.labels.includes('wiki')) return '#7057ff';
        }
        return '#4f6df5';
      }

      // ノードのサイズを決定する関数
      function getNodeSize(node) {
        // コメント数に応じてサイズを変更
        const baseSize = 5;
        if (node.comments > 10) return baseSize + 3;
        if (node.comments > 5) return baseSize + 2;
        if (node.comments > 0) return baseSize + 1;
        return baseSize;
      }
      
      // ラベルを短縮する関数
      function truncateLabel(text) {
        return text.length > 15 ? text.substring(0, 15) + '...' : text;
      }
      
      // ズームレベルに応じてラベルの表示を調整する関数
      function adjustLabels(zoomLevel) {
        // ズームレベルに応じてラベルの透明度を調整
        if (isFullGraph) {
          const showLabels = d3.select('#toggle-labels').classed('active');
          if (showLabels) {
            label.style('opacity', zoomLevel < 0.7 ? 0 : 1);
          } else {
            label.style('opacity', d => d.isCurrent ? 1 : 0);
          }
        } else {
          label.style('opacity', zoomLevel < 0.7 ? 0 : 1);
        }
      }

      // 選択されたノードの詳細を表示する関数
      function showNodeDetails(node) {
        const nodeDetails = document.getElementById('node-details');
        if (!nodeDetails) return;

        // 日付フォーマット
        const formatDate = (dateString) => {
          const date = new Date(dateString);
          return date.toLocaleDateString('ja-JP', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit'
          });
        };

        // 入リンク・出リンクを取得
        const incomingLinks = graphData.links.filter(l => l.target.id === node.id);
        const outgoingLinks = graphData.links.filter(l => l.source.id === node.id);

        // HTMLを構築
        let html = `
          <h4>${node.title}</h4>
          <div class="node-meta">
            <div><span>Issue番号:</span> <span>#${node.id}</span></div>
            <div><span>作成日:</span> <span>${formatDate(node.created_at)}</span></div>
            <div><span>更新日:</span> <span>${formatDate(node.updated_at)}</span></div>
            <div><span>コメント数:</span> <span>${node.comments}</span></div>
            ${node.labels && node.labels.length ? 
              `<div><span>ラベル:</span> <span>${node.labels.join(', ')}</span></div>` : 
              ''}
          </div>
        `;

        // リンク情報
        html += `<div class="node-links">`;
        
        // 入リンク
        html += `<h5>入リンク (${incomingLinks.length})</h5>`;
        if (incomingLinks.length > 0) {
          html += `<ul class="link-list">`;
          incomingLinks.forEach(l => {
            const sourceNode = graphData.nodes.find(n => n.id === l.source.id);
            html += `<li><a href="${sourceNode.url}" title="${sourceNode.title}">${sourceNode.title}</a></li>`;
          });
          html += `</ul>`;
        } else {
          html += `<p>このノードを参照しているページはありません</p>`;
        }

        // 出リンク
        html += `<h5>出リンク (${outgoingLinks.length})</h5>`;
        if (outgoingLinks.length > 0) {
          html += `<ul class="link-list">`;
          outgoingLinks.forEach(l => {
            const targetNode = graphData.nodes.find(n => n.id === l.target.id);
            html += `<li><a href="${targetNode.url}" title="${targetNode.title}">${targetNode.title}</a></li>`;
          });
          html += `</ul>`;
        } else {
          html += `<p>このノードから他のページへのリンクはありません</p>`;
        }

        html += `</div>`;

        nodeDetails.innerHTML = html;
      }

      // リンクの強調表示
      function highlightNodeLinks(nodeId, highlight = true) {
        // 関連リンクを強調
        link
          .classed('highlighted', d => 
            highlight && (d.source.id === nodeId || d.target.id === nodeId)
          )
          .style('opacity', d => 
            highlight 
              ? (d.source.id === nodeId || d.target.id === nodeId ? 1 : 0.1)
              : 0.6
          );

        // 関連ノードとラベルを強調
        const connectedNodeIds = new Set();
        if (highlight) {
          graphData.links.forEach(l => {
            if (l.source.id === nodeId) connectedNodeIds.add(l.target.id);
            if (l.target.id === nodeId) connectedNodeIds.add(l.source.id);
          });
          connectedNodeIds.add(nodeId);
        }

        node
          .classed('selected', d => highlight && d.id === nodeId)
          .style('opacity', d => 
            highlight 
              ? (connectedNodeIds.has(d.id) ? 1 : 0.2)
              : 1
          );

        const showLabels = d3.select('#toggle-labels').classed('active');
        label
          .classed('highlighted', d => highlight && d.id === nodeId)
          .style('opacity', d => {
            if (!isFullGraph) return 1;
            if (d.isCurrent) return 1;
            if (d.id === nodeId) return 1;
            if (highlight && connectedNodeIds.has(d.id)) return 1;
            return showLabels ? 0.7 : 0;
          });
      }
      
      // ノードのマウスオーバー処理
      function nodeMouseOver(event, d) {
        // ノードを強調表示
        d3.select(this)
          .transition()
          .duration(200)
          .attr('r', d.isCurrent ? 10 : getNodeSize(d) + 2);
        
        // 関連リンク、ノード、ラベルを強調
        if (isFullGraph) {
          highlightNodeLinks(d.id);
        } else {
          // ミニグラフの場合はより単純な強調表示
          link.transition()
            .duration(200)
            .style('opacity', l => 
              l.source.id === d.id || l.target.id === d.id ? 1 : 0.1);
          
          node.transition()
            .duration(200)
            .style('opacity', n => 
              n.id === d.id || 
              graphData.links.some(l => 
                (l.source.id === d.id && l.target.id === n.id) || 
                (l.target.id === d.id && l.source.id === n.id)
              ) ? 1 : 0.3);
          
          label.transition()
            .duration(200)
            .style('opacity', n => 
              n.id === d.id || 
              graphData.links.some(l => 
                (l.source.id === d.id && l.target.id === n.id) || 
                (l.target.id === d.id && l.source.id === n.id)
              ) ? 1 : 0.1);
        }
        
        // ツールチップを表示
        tooltip.transition()
          .duration(200)
          .style('opacity', 0.9);
        
        tooltip.html(`
          <div class="node-tooltip-title">${d.title}</div>
          <div class="node-tooltip-info">Issue #${d.id}</div>
          ${d.labels && d.labels.length > 0 ? 
            `<div class="node-tooltip-info">ラベル: ${d.labels.join(', ')}</div>` : ''}
          ${d.comments > 0 ? 
            `<div class="node-tooltip-info">コメント数: ${d.comments}</div>` : ''}
        `)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');
      }
      
      // ノードのマウスアウト処理
      function nodeMouseOut(event, d) {
        // ノードを元に戻す
        d3.select(this)
          .transition()
          .duration(200)
          .attr('r', d.isCurrent ? 8 : getNodeSize(d));
        
        // リンク、ノード、ラベルを元に戻す
        if (isFullGraph) {
          // 選択状態のノードが存在するかチェック
          const selectedNode = node.filter('.selected');
          if (selectedNode.size() > 0) {
            // 選択状態のノードがあれば、そのノードの強調を維持
            const selectedId = selectedNode.datum().id;
            highlightNodeLinks(selectedId);
          } else {
            // 選択状態のノードがなければ、すべて通常表示に戻す
            highlightNodeLinks(null, false);
          }
        } else {
          // ミニグラフの場合の処理
          link.transition()
            .duration(200)
            .style('opacity', 0.6);
          
          node.transition()
            .duration(200)
            .style('opacity', 1);
          
          label.transition()
            .duration(200)
            .style('opacity', 1);
        }
        
        // ツールチップを非表示
        tooltip.transition()
          .duration(200)
          .style('opacity', 0);
      }
      
      // ノードクリック時の挙動
      function nodeClicked(event, d) {
        if (event.defaultPrevented) return;
        event.preventDefault();
        
        if (isFullGraph) {
          // 現在のノードが選択されているか
          const isCurrentlySelected = d3.select(this).classed('selected');
          
          // すべてのノードから選択状態を解除
          node.classed('selected', false);
          
          if (!isCurrentlySelected) {
            // 選択状態にして詳細を表示
            d3.select(this).classed('selected', true);
            highlightNodeLinks(d.id);
            showNodeDetails(d);
          } else {
            // 選択解除
            highlightNodeLinks(null, false);
            document.getElementById('node-details').innerHTML = 
              '<div class="no-selection">ノードを選択すると詳細が表示されます</div>';
          }
        } else {
          // ミニグラフの場合は詳細ページに遷移
          if (d.url) {
            window.location.href = d.url;
          }
        }
      }
      
      // シミュレーションの設定
      const simulation = d3.forceSimulation(graphData.nodes)
        .force('link', d3.forceLink(graphData.links).id(d => d.id).distance(isFullGraph ? 100 : 70))
        .force('charge', d3.forceManyBody().strength(isFullGraph ? -250 : -150))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .on('tick', ticked);
      
      // シミュレーション更新時の描画更新
      function ticked() {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);
        
        node
          .attr('cx', d => d.x = Math.max(10, Math.min(width - 10, d.x)))
          .attr('cy', d => d.y = Math.max(10, Math.min(height - 10, d.y)));
        
        label
          .attr('x', d => d.x)
          .attr('y', d => d.y - 10);
      }
      
      // ズームコントロールのイベントハンドラー
      if (isFullGraph) {
        // ズームイン
        document.getElementById('zoom-in')?.addEventListener('click', () => {
          svg.transition().duration(300).call(
            zoom.scaleBy, 1.3
          );
        });
        
        // ズームアウト
        document.getElementById('zoom-out')?.addEventListener('click', () => {
          svg.transition().duration(300).call(
            zoom.scaleBy, 1 / 1.3
          );
        });
        
        // リセット
        document.getElementById('reset-graph')?.addEventListener('click', () => {
          svg.transition().duration(300).call(
            zoom.transform, d3.zoomIdentity
          );
        });
      }
      
      // 現在のノードにスクロールしてフォーカス
      if (currentId) {
        const currentNode = graphData.nodes.find(n => n.id === currentId);
        if (currentNode && isFullGraph) {
          setTimeout(() => {
            svg.transition().duration(500).call(
              zoom.transform, 
              d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(1.2)
                .translate(-currentNode.x, -currentNode.y)
            );
          }, 500);
        }
      }
    }
  });
</script>

<script is:inline define:vars={{dataJson}}>
  document.addEventListener('DOMContentLoaded', () => {
    const graph = document.getElementById('knowledge-graph');
    if (graph) {
      graph.setAttribute('data-graph', dataJson);
    }
  });
</script>
