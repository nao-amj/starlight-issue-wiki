---
import type { GitHubIssue } from '../data/types';
import { findBidirectionalLinks } from '../lib/zettelkasten';
import { BASE_PATH } from '../config';

export interface Props {
  issues: GitHubIssue[];
  currentIssueNumber?: number;
  showFullGraph?: boolean;
}

const { issues, currentIssueNumber, showFullGraph = false } = Astro.props;

// 双方向リンクを検出
const bidirectionalLinks = findBidirectionalLinks(issues);

// グラフデータの準備
const graphData = {
  nodes: issues.map(issue => ({
    id: issue.number,
    title: issue.title,
    url: `${BASE_PATH}/wiki/${issue.number}`,
    isCurrent: issue.number === currentIssueNumber,
    labels: issue.labels ? issue.labels.map(label => 
      typeof label === 'object' ? label.name : label
    ) : []
  })),
  links: []
};

// リンクデータの準備
issues.forEach(issue => {
  if (!issue.body) return;
  
  // [[...]]形式のリンクを検出
  const wikiLinks = issue.body.match(/\[\[(.*?)\]\]/g);
  if (wikiLinks) {
    wikiLinks.forEach(link => {
      const linkedTitle = link.substring(2, link.length - 2).trim();
      const linkedIssue = issues.find(i => 
        i.title.toLowerCase() === linkedTitle.toLowerCase() ||
        i.title.toLowerCase().includes(linkedTitle.toLowerCase())
      );
      
      if (linkedIssue && linkedIssue.number !== issue.number) {
        graphData.links.push({
          source: issue.number,
          target: linkedIssue.number,
          bidirectional: bidirectionalLinks.has(issue.number) && 
            bidirectionalLinks.get(issue.number)?.includes(linkedIssue.number),
          type: 'wiki'
        });
      }
    });
  }
  
  // #番号形式のリンクを検出
  const issueRefs = issue.body.match(/#(\d+)/g);
  if (issueRefs) {
    issueRefs.forEach(ref => {
      const refNumber = parseInt(ref.substring(1), 10);
      const refIssue = issues.find(i => i.number === refNumber);
      
      if (refIssue && refIssue.number !== issue.number) {
        // 重複リンクを防ぐ
        const existingLink = graphData.links.find(
          link => (link.source === issue.number && link.target === refIssue.number) ||
                 (link.source === refIssue.number && link.target === issue.number)
        );
        
        if (!existingLink) {
          graphData.links.push({
            source: issue.number,
            target: refIssue.number,
            bidirectional: bidirectionalLinks.has(issue.number) && 
              bidirectionalLinks.get(issue.number)?.includes(refIssue.number),
            type: 'reference'
          });
        }
      }
    });
  }
});

// 小さいグラフの場合はフィルタリング
let filteredGraphData = graphData;
if (!showFullGraph && currentIssueNumber) {
  // 現在のノードと直接リンクしているノードのみを表示
  const connectedNodeIds = new Set();
  connectedNodeIds.add(currentIssueNumber);
  
  graphData.links.forEach(link => {
    if (link.source === currentIssueNumber) {
      connectedNodeIds.add(link.target);
    }
    if (link.target === currentIssueNumber) {
      connectedNodeIds.add(link.source);
    }
  });
  
  filteredGraphData = {
    nodes: graphData.nodes.filter(node => connectedNodeIds.has(node.id)),
    links: graphData.links.filter(link => 
      connectedNodeIds.has(link.source) && connectedNodeIds.has(link.target)
    )
  };
}

// D3.jsにわたすデータをJSON文字列として埋め込む
const dataJson = JSON.stringify(showFullGraph ? graphData : filteredGraphData);
---

<div class="knowledge-graph-container">
  <div id="knowledge-graph" class={showFullGraph ? 'full-graph' : 'mini-graph'} data-current-id={currentIssueNumber || 0}>
    <!-- グラフはJavaScriptで描画 -->
    <div class="graph-loading">
      <span class="loading-spinner"></span>
      <span>グラフを読み込み中...</span>
    </div>
  </div>
  
  {showFullGraph && (
    <div class="graph-controls">
      <button id="zoom-in" class="graph-button" title="拡大">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          <line x1="11" y1="8" x2="11" y2="14"></line>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      </button>
      <button id="zoom-out" class="graph-button" title="縮小">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      </button>
      <button id="reset-graph" class="graph-button" title="リセット">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
          <path d="M3 3v5h5"></path>
        </svg>
      </button>
    </div>
  )}
</div>

<style>
  .knowledge-graph-container {
    width: 100%;
    overflow: hidden;
    border-radius: 8px;
    border: 1px solid #eee;
    margin: 1rem 0;
    position: relative;
  }
  
  .dark .knowledge-graph-container {
    border-color: #444;
  }
  
  #knowledge-graph {
    width: 100%;
    background-color: #f9f9f9;
    position: relative;
    overflow: hidden;
  }
  
  .dark #knowledge-graph {
    background-color: #1a1a1a;
  }
  
  .mini-graph {
    height: 250px;
  }
  
  .full-graph {
    height: 600px;
  }
  
  .graph-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    color: #666;
    font-size: 0.9rem;
  }
  
  .dark .graph-loading {
    color: #ccc;
  }
  
  .loading-spinner {
    display: inline-block;
    width: 30px;
    height: 30px;
    border: 3px solid rgba(0, 0, 0, 0.1);
    border-radius: 50%;
    border-top-color: var(--color-primary);
    animation: spin 1s ease-in-out infinite;
    margin-bottom: 0.5rem;
  }
  
  .dark .loading-spinner {
    border-color: rgba(255, 255, 255, 0.1);
    border-top-color: var(--color-primary);
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  .graph-controls {
    position: absolute;
    bottom: 10px;
    right: 10px;
    display: flex;
    gap: 5px;
    z-index: 10;
  }
  
  .graph-button {
    background-color: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 5px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    color: #555;
  }
  
  .dark .graph-button {
    background-color: #333;
    border-color: #555;
    color: #ccc;
  }
  
  .graph-button:hover {
    background-color: #f0f0f0;
    transform: translateY(-2px);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  }
  
  .dark .graph-button:hover {
    background-color: #444;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
  }
  
  /* D3.js グラフのスタイル */
  :global(.graph-node) {
    cursor: pointer;
    transition: fill 0.3s, r 0.3s;
  }
  
  :global(.graph-node:hover) {
    stroke: #f04050;
    stroke-width: 2px;
  }
  
  :global(.graph-node.current) {
    stroke-width: 2px;
    stroke: #f04050;
  }
  
  :global(.graph-link) {
    stroke-opacity: 0.6;
    transition: stroke 0.3s, stroke-width 0.3s, stroke-opacity 0.3s;
  }
  
  :global(.graph-link:hover) {
    stroke-opacity: 1;
    stroke-width: 2px;
  }
  
  :global(.graph-link.bidirectional) {
    stroke-width: 2px;
  }
  
  :global(.node-label) {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    font-size: 10px;
    pointer-events: none;
    text-anchor: middle;
    transition: opacity 0.3s;
    user-select: none;
  }
  
  .dark :global(.node-label) {
    fill: #eee;
  }
  
  :global(.node-tooltip) {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.9);
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    z-index: 100;
    max-width: 250px;
    transition: opacity 0.2s;
    opacity: 0;
  }
  
  .dark :global(.node-tooltip) {
    background-color: rgba(40, 40, 40, 0.9);
    color: #eee;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
  }
  
  :global(.node-tooltip-title) {
    font-weight: bold;
    margin-bottom: 4px;
    color: var(--color-primary);
  }
  
  :global(.node-tooltip-info) {
    font-size: 11px;
    color: #666;
  }
  
  .dark :global(.node-tooltip-info) {
    color: #ccc;
  }
</style>

<script>
  // D3.jsを使用したグラフの描画
  document.addEventListener('DOMContentLoaded', () => {
    // 必要なライブラリを動的にロード
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/d3@7';
    script.onload = initGraph;
    document.head.appendChild(script);
    
    function initGraph() {
      const graphElement = document.getElementById('knowledge-graph');
      if (!graphElement) return;
      
      // コンテナデータ
      const graphData = JSON.parse(graphElement.getAttribute('data-graph') || '{"nodes":[],"links":[]}');
      const isFullGraph = graphElement.classList.contains('full-graph');
      const currentId = parseInt(graphElement.getAttribute('data-current-id') || '0', 10);
      
      // グラフの読み込み中表示を削除
      graphElement.querySelector('.graph-loading')?.remove();
      
      // SVG要素の作成
      const width = graphElement.clientWidth;
      const height = graphElement.clientHeight;
      
      const svg = d3.select('#knowledge-graph')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, width, height]);
      
      // ズーム機能の定義
      const zoom = d3.zoom()
        .scaleExtent([0.1, 5])
        .on('zoom', (event) => {
          container.attr('transform', event.transform);
          // ズームレベルに応じてラベルの表示を調整
          adjustLabels(event.transform.k);
        });
      
      // SVGにズーム機能を追加
      svg.call(zoom);
      
      // グループコンテナ（ズーム用）
      const container = svg.append('g')
        .attr('class', 'graph-container');
      
      // リンクを描画するためのグループ
      const link = container.append('g')
        .attr('class', 'links')
        .selectAll('line')
        .data(graphData.links)
        .enter().append('line')
        .attr('class', d => `graph-link ${d.bidirectional ? 'bidirectional' : ''} ${d.type || ''}`)
        .attr('stroke', d => d.bidirectional ? '#0fa968' : '#999')
        .attr('stroke-width', d => d.bidirectional ? 2 : 1);
      
      // ノードを描画するためのグループ
      const node = container.append('g')
        .attr('class', 'nodes')
        .selectAll('circle')
        .data(graphData.nodes)
        .enter().append('circle')
        .attr('class', d => `graph-node ${d.isCurrent ? 'current' : ''}`)
        .attr('r', d => d.isCurrent ? 8 : 5)
        .attr('fill', d => d.isCurrent ? '#f04050' : getNodeColor(d))
        .on('mouseover', nodeMouseOver)
        .on('mouseout', nodeMouseOut)
        .on('click', nodeClicked);
      
      // ラベルの描画（常に表示）
      const label = container.append('g')
        .attr('class', 'labels')
        .selectAll('text')
        .data(graphData.nodes)
        .enter().append('text')
        .attr('class', 'node-label')
        .attr('dy', d => d.isCurrent ? '-1.2em' : '-0.5em')
        .text(d => truncateLabel(d.title))
        .style('opacity', isFullGraph ? 0.7 : 1);
      
      // ツールチップの作成
      const tooltip = d3.select('body').append('div')
        .attr('class', 'node-tooltip')
        .style('opacity', 0);
      
      // ノードの色を決定する関数
      function getNodeColor(node) {
        if (node.isCurrent) return '#f04050';
        if (node.labels && node.labels.length > 0) {
          if (node.labels.includes('documentation')) return '#0075ca';
          if (node.labels.includes('feature')) return '#a2eeef';
          if (node.labels.includes('wiki')) return '#7057ff';
        }
        return '#4f6df5';
      }
      
      // ラベルを短縮する関数
      function truncateLabel(text) {
        return text.length > 15 ? text.substring(0, 15) + '...' : text;
      }
      
      // ズームレベルに応じてラベルの表示を調整する関数
      function adjustLabels(zoomLevel) {
        // ズームレベルに応じてラベルの透明度を調整
        label.style('opacity', zoomLevel < 0.7 ? 0 : 1);
      }
      
      // ノードのマウスオーバー処理
      function nodeMouseOver(event, d) {
        // ノードを強調表示
        d3.select(this)
          .transition()
          .duration(200)
          .attr('r', d.isCurrent ? 10 : 7);
        
        // 関連するリンクを強調表示
        link.transition()
          .duration(200)
          .style('opacity', l => 
            l.source.id === d.id || l.target.id === d.id ? 1 : 0.1);
        
        // 関連するノードを強調表示
        node.transition()
          .duration(200)
          .style('opacity', n => 
            n.id === d.id || 
            graphData.links.some(l => 
              (l.source.id === d.id && l.target.id === n.id) || 
              (l.target.id === d.id && l.source.id === n.id)
            ) ? 1 : 0.3);
        
        // ラベルの表示を調整
        label.transition()
          .duration(200)
          .style('opacity', n => 
            n.id === d.id || 
            graphData.links.some(l => 
              (l.source.id === d.id && l.target.id === n.id) || 
              (l.target.id === d.id && l.source.id === n.id)
            ) ? 1 : 0.1);
        
        // ツールチップを表示
        tooltip.transition()
          .duration(200)
          .style('opacity', 0.9);
        
        tooltip.html(`
          <div class="node-tooltip-title">${d.title}</div>
          <div class="node-tooltip-info">Issue #${d.id}</div>
          ${d.labels && d.labels.length > 0 ? 
            `<div class="node-tooltip-info">ラベル: ${d.labels.join(', ')}</div>` : ''}
        `)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');
      }
      
      // ノードのマウスアウト処理
      function nodeMouseOut(event, d) {
        // ノードを元に戻す
        d3.select(this)
          .transition()
          .duration(200)
          .attr('r', d.isCurrent ? 8 : 5);
        
        // リンクを元に戻す
        link.transition()
          .duration(200)
          .style('opacity', 0.6);
        
        // ノードとラベルを元に戻す
        node.transition()
          .duration(200)
          .style('opacity', 1);
        
        label.transition()
          .duration(200)
          .style('opacity', isFullGraph ? 0.7 : 1);
        
        // ツールチップを非表示
        tooltip.transition()
          .duration(200)
          .style('opacity', 0);
      }
      
      // ノードクリック時の挙動
      function nodeClicked(event, d) {
        if (event.defaultPrevented) return;
        event.preventDefault();
        
        if (d.url) {
          window.location.href = d.url;
        }
      }
      
      // シミュレーションの設定
      const simulation = d3.forceSimulation(graphData.nodes)
        .force('link', d3.forceLink(graphData.links).id(d => d.id).distance(isFullGraph ? 100 : 70))
        .force('charge', d3.forceManyBody().strength(isFullGraph ? -250 : -150))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .on('tick', ticked);
      
      // シミュレーション更新時の描画更新
      function ticked() {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);
        
        node
          .attr('cx', d => d.x = Math.max(10, Math.min(width - 10, d.x)))
          .attr('cy', d => d.y = Math.max(10, Math.min(height - 10, d.y)));
        
        label
          .attr('x', d => d.x)
          .attr('y', d => d.y - 10);
      }
      
      // ズームコントロールのイベントハンドラー
      if (isFullGraph) {
        // ズームイン
        document.getElementById('zoom-in')?.addEventListener('click', () => {
          svg.transition().duration(300).call(
            zoom.scaleBy, 1.3
          );
        });
        
        // ズームアウト
        document.getElementById('zoom-out')?.addEventListener('click', () => {
          svg.transition().duration(300).call(
            zoom.scaleBy, 1 / 1.3
          );
        });
        
        // リセット
        document.getElementById('reset-graph')?.addEventListener('click', () => {
          svg.transition().duration(300).call(
            zoom.transform, d3.zoomIdentity
          );
        });
      }
      
      // 現在のノードにスクロールしてフォーカス
      if (currentId) {
        const currentNode = graphData.nodes.find(n => n.id === currentId);
        if (currentNode && isFullGraph) {
          setTimeout(() => {
            svg.transition().duration(500).call(
              zoom.transform, 
              d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(1.2)
                .translate(-currentNode.x, -currentNode.y)
            );
          }, 500);
        }
      }
    }
  });
</script>

<script is:inline define:vars={{dataJson}}>
  document.addEventListener('DOMContentLoaded', () => {
    const graph = document.getElementById('knowledge-graph');
    if (graph) {
      graph.setAttribute('data-graph', dataJson);
    }
  });
</script>
